*자바 = 톱니형 배열
*구조적인 프로그래밍에서 가장 중요한것은 함수로 프로그램을 나누는것
*구조적인 프로그램을 만드는 두가지 방법
	1. 기존의 이미 존재하는 (절차적) 프로그램을 잘라서 조각내고 구조를 만들어감
		—> Bottom up
	2. 아예 코드가 없는 경우 처음부터 설계해야함
		—>Top down

* 함수의 고립화 -> 전역변수의 사용을 함수의 매개변수를 이용해 고립시킴
			-> 외부의 변화가 있어도 함수가 고립되어 있기 때문에 오류 발생 줄일 수 있음
			-> 프로그램을 만들때 배열 연산을 최소화 할 수 있도록 지역변수를 만들어주는것이 바람직하다.
			-> 즉 매개변수 = 함수 외부로부터의 영향을 받지 않도록 하는 중요한 도구 역할

* 함수명명규칙 -> 숫자로 시작X
			->문자사이 공백 X
			->특수문자 사용 X
			->자바는 주로 camel(낙타)표기 시작은 소문자 두번째 단어부터 대문자 시작

* 프로그램 작성 방법 : 경험이 있으면 Top down
				경험이 없으면 통짜로 만들고 bottom up해 구조적으로 변경하기


* 데이터 구조화 :  우리가 머릿속으로 생각하는 데이터 = entity 또는 개념단위의데이터
			-클래스의 선언은 참조형식으로 선언됨
			 (선언은 값 형식, 참조형식으로 나뉜다.)
			 (값 형식은 기본형(정수, 실수, 문자형등)만 맞음, 그 외에 모든 형식은 참조형식이다.)
			-값 형식이 아닌 참조형식들은 모두 new연산자를 이용해 공간을 만들어줘야함 그렇지 않으면 NULL을 가리킨다.

* 구조체 배열 Exam[] exams = new Exam[3];
			위의 구조체 선언은 참조변수 3개만 배열형식으로 만들어진것이지만
			객체는 Exam 객체가 생성되지는 않았다.
			따라서 따로 생성을 해줘야함 ex) exams[0] = new Exam();

* 메소드나 함수 안에서 for문 내부에 변수를 선언하게되면 여러번 선언되는것이 아니다.
 즉 for문에 있든 밖에있든 한번만 선언되고 만다.

* 함수 단위로 공유해야할 데이터라면 더 큰 구조체로 묶어서 정리하여 사용한다.

* 똑같은 기능의 함수를 2개 만들고 오버로딩이 됐을경우 매개변수 인자가 많은쪽이 인자가 없는쪽이 할 수 있는 일을 다 할 수 있으므로 인자가 적은쪽의 함수내용을 지우고 내부에 인자가 많은 함수를 호출하여 집중화 시킨다.




<<객체지향>>
인스턴스 메소드 - 스태틱 선언이 빠져있음, 반드시 인스턴스를 생성해야 사용가능
			메소드 내부에서는 this 키워드로 자신을 가리킴 
클래스메소드(함수, 정적메소드) - 스태틱 선언이 되어있음, 인스턴스 생성없이 사용가능



<<생성자>>
객체 생성시 ExamList exams = new ExamList();
위의 코드에서 new ExamList(); 는 사실 new ExamList + (); 로 나뉨 좌측은 객체 생성 우측 ();는 생성자 실행이다
즉 new ExamList이 실행된 결과로 객체가 있어야만 실행할수있는 (); 함수 즉 생성자
생성자 = 실행될때 한번만 실행되어야함
생성자는 반환타입이 없고 클래스 이름과 동일하게 적용해야함
this() 생성자 사용시 반드시 첫번째 라인에 위치해야한다.



<<getters and setters>>
클래스의 데이터를 연산, 대입, 가져오는 경우는 함수를 통해 전달한다.
	ex getXXX(), setXXX(), total(), getSum(), getAvg(); 



<<캡슐들의 사용관계>>
UI(ExamConsole) -> 목록(ExamList) -> 데이터(Exam)의 구조에서
일반적으로 List라 이름붙은 클래스들은 어떤 객체를 가지고 있긴 하지만 사용하진 않는다

Has a 상속 - 캡슐이 다른 캡슐의 객체를 가지고 있는 상태
Has a : Aggregation has a(부모와 자식의 생성이 동시에 이루어지지 않고 필요시 불러옴) 이게 ExamList와 Exam의 관계
	:  Composition has a(부모 객체가 생성되는 동시에 자식 객체가 같이 생성됨 즉 생성시기가 동일함) ExamConsole, ExamList의 관계
Dependency(의존객체, 부품) : 함수 내에서 일시적으로 사용되는 객체들



<< 자바 클래스 재사용 하는 방법>>
	파일을 단순히 복사해서 같은 패키지에 복사하는 방법 -> 재사용이 아니고 새거를 가져다 쓰는것 (사용)
	이미 만들어서 배포된 것을 다시 사용하는 것 -> 재사용
* 배포방법 
	1. 컴파일 -> Exam.class 파일 생성
	2. 클래스 파일 압축 -> Exam.zip 생성
	3.  Jar -> Exam.jar (자바를 위한 압축파일이라는 의미)
	
	>> java -> jar = 같은 압축이지만 확장자 jar, 압축시 자바 파일을 클래스파일로 컴파일하여 압축하고 jar로 확장자 변경

*이클립스 배포방법
	1. 원하는 프로젝트 우측 버튼 -> 이클립스 내부에서 패키지 우측 버튼 -> Export -> java로 대신 해주는 방법이 있다.
		( general -> archive file = 기존에 있는 프로젝트 중 소스코드 자체 즉 자바 파일을 압축해서 배포할때 사용됨(즉 소스코드 배포시 사용)
	2. 적용하기 원하는 프로젝트 우측버튼 -> Build Path -> Configure Build Path -> 상단 Libraries -> 우측 Add External JARs 선택후 만들어진 jar 파일 적용후 닫기
	3. 프로젝트에 임포트 해서 사용하면 재사용 완료



<<is a 상속>>
	*상속받은 객체를 new해 공간을 만들면 객체가 2개가 생성됨
	*Exam 객체 + 자기가 확장한 새로운 변수나 메소드 확장됨
	*상속받은 클래스를 객체화 할때는 부모 객체들이 다 들어있음 : 부모객체 + alpha

	*객체 내부서 사용시 : this 키워드를 이용
	*객체 내부에서 부모객체 사용시 : super 키워드 이용 >> Override된 함수가 있고 그 함수를 사용하면 부모객체가 아닌 자식객체에서 가져옴 만약 부모객체에서 정의된 메소드 사용 원할시
										  super키워드 이용해서 사용하면 된다.
	*override된 메소드가 없고 그 메소드를 호출할시 부모객체에 존재하는 메소드 사용
	*생성자를 호출하기 위해서는 갓 생성된 객체만 생성할 수 있음
		ex) public NewlecExam() {
			this.com = 3;		<< 코드 집중화를 위해 오버로딩한 생성자에서 다른 생성자 호출이전에 객체변수에 값 대입시 this(0,0,0,0) 구문은 오류발생 따라서 순서를반대로하면 됨
			this(0, 0, 0, 0);
			}

	* 상속이후 부모참조형식으로 자식객체를 생성하고 내부 메소드를 사용시 부모 메소드를 불러오는것이 아닌 자식 메소드를 불러온다
	이유는 오버라이드된 함수가 우선순위가 있기 때문 즉 참조형식 메소드보다 객체형식 메소드가 우선순위가 있으므로 부모메소드를 들렀다가 오버라이드된게 있을경우 그걸 호출
	하지만 부모클래스에 없는 메소드가 자식클래스에 있을경우 위와같이 불러오면 오류가 발생한다. >> 부모클래스 내에 함수 자체가 없으므로 자식에 있는 메소드는 오버라이드 된게 아닌
	새로이 정의된 함수이므로 접근할 수 없다.



<<추상클래스>>
*추상 메소드를 하나라도 가지고 있는 클래스를 추상 클래스라고 함 즉, 일반 클래스에는 추상 메소드가 있을 수 없음

*클래스들은 공통분모가 있고 공통분모를 따로 모아놓아 상속을 시키면 그 클래스는 추상클래스가 된다.

*캡슐단위의 공통서비스를 모음(개체들의 공통서비스 집중화)

*추상클래스의 장점 : 코드 집중화, 일괄처리

*공통분모(또는 뼈대)로써의 클래스가 되면 기울기체로 표시 >> 뼈대로만 사용하게 해야함 즉 new연산자로 객체화되는것을 막아야함 >> abstract 키워드 이용하면됨

*추상클래스의 두가지 용도 1. 한 프로젝트 내에서 공통분모로 사용될 수 있는 자료형을 만들목적으로 집중화
				    2. 공통분모로써 다음버젼을 만들기위한 재사용 모듈 (다른 프로젝트)



<<추상메소드 24강>>
*공통으로 나타나는 서비스 함수만 추상클래스에 올려놓음 즉 메소드의 뼈대만 올려놓으면 >> 추상메소드가 됨
*이것 역시 기울임체로 표기
*메소드 앞에 abstract키워드를 붙여 생성하고 그것을 (is a)상속받는 자식 클래스가 추상 메소드를 구현하지 않으면 오류가 발생한다.

* 추상 메소드는 공통 자료형이라 할 수 있는 추상 클래스가 가지고 있는 공통 서비스 함수다. >> 다만 공통 서비스지만 구현이 공통이 아니고 서비스라 하는 목록이 공통이다.
	ex) 추상 클래스 shape : <—— Rect, Circle, Line자식 클래스가 있을때 draw()메소드는 각각 다르므로 공통 서비스 목록만 shape클래스에 구현하고 구현은 각각의 자식클래스에 구현한다.
		다만 이를 간편화 하기 위해 자식클래스까지만 사용할 수 있는 protected지정자를 이용해 자식클래스가 처음부터 메소드를 구현해야하는 부담을 줄일 수 있다.

****** ExamConsole은 Exam 객체의 total(), avg() 메소드를 이용하여 본인의 print(), input() 메소드를 구현함 하지만 total, avg는 공통기능이며 내가 사용할 수 없는 상황이다(종류에 따라 바뀌므로)따라서 추상메소드로 변경하고 이것에 대한 구현은 Exam클래스를 상속받는 하위클래스에게 위임함.

* 기존의 구현되어있던 기능을 가져다 쓰지 못하고 자식클래스에서 통째로 구현해야하는 부담을 줄여주기 위해 자식객체만
사용할 수 있게 메소드를 만들어줄 수 도 있음 >> Exam 클래스의 onTotal()



<<jar변환없이 라이브러리 처럼 프로젝트 재사용 방법>>
1. Build Path > Configure Build path > project > add > 원하는 프로젝트 선택
2. 만약 서로 다른 프로젝트에서 패키지의 이름이 같다면 같은 패키지에 있다고 보고 그걸 가져다 연동시켜줌
	(jar, 프로젝트, 배포된 내용 달라도 같은패키지에 있다고 봄)

<<팩토리 메소드>>
* 객체를 생성하는 부분을 자식에게 위임해서 자식이 객체 생성부분을 책임지게 하는 메소드 makeExam()

<<이벤트 메소드>>
*이벤트 메소드 : 어떤 사건에 기반되고 실행되는 함수 (onInput(Exam exam), onPrint(Exam exam) )
	-자식객체에서 추가되는 과목 성적을 자식에게 맡김
	-입력을 받기위한 로직이 진행되는 과정에서 확장되는 부분은 자식이 입력하라는 의미로 on사용
	-이벤트 메소드 = 어떤 사건에 기반되어 실행되는 함수

<< Interface >>

<인터페이스의 개념>
*인터페이스 == 코드의 분리
*인터페이스는 두가지 형태의 인터페이스가 존재
  -일반화 되어있는 인터페이스: 어떤것, 장소, 시간을 접근해야할때 바로 접근할 수 없음(여러가지이유)
					접근하게 해주는 방법 또는 도구 >>>>> interface
						ex) 인터스텔라의 웜홀(다른 우주로 접근시켜줌)
  -직접 사용할 수 없는 대상(떨어져있고 분리되어있음)을 만날 수 있게 해주는 접점 == interface
	>> Java에서도 필요함.


<Java 에서의 interface>
*자바의 객체지향 : 어떤 특정 부품을 조립할때 일체형(composition has a)으로 할지 단순 사용 관계로 분리하여 만들지 고민해야함
	>> 만약 분리하겠다 하면 그냥 떼어내는것이 아닌 나중에 연결해서 사용할 수 있게 하는 접점 == interface

* interface : 분리된 부품을 사용하기 위한 규칙이나 규약 즉 약속
객체 생성전 클래스처럼 인터페이스도 하나의 틀을 만들어야함
 > 구문 
	interface Battery { 
		int getEnergy();
		Boolean checkVolt(…);	
	}


> 사용할 클래스 에서 인터페이스를 이용한 변수 선언
	private Battery battery; >>인터페이스 형식의 자료형
	
	battery.getEnergy();
	battery.checkVolt(본체정보);		>> 자료형을 만들고 구현되지도 않은것들을 일단 호출함

>실제 부품과 사용할 클래스를 합칠시 키워드가 필요함
	.setBattery(battery:Battery)

>실제로 배터리를 구현하기 위한 코드 (인터페이스 상속==인터페이스를 내가 구현하겠다)
 	class NewlecBattery implements Battery {
		public int getEnergy() {
			//메소드 구현
		}
		public Boolean checkVolt(PhoneInfo info) {
			//메소드 구현
		}
	}
 

따라서 자바에서의 인터페이스 정의방법
1. 인터페이스란 키워드와 함께 인터페이스명 정의(배터리) > 2.인터페이스를 이용해 만들던 클래스를 마무리지음(스마트폰, 비어있기 때문에 아직 동작 불가능)
> 3.배터리라는 인터페이스를 구현하고 있는 객체를 구현(인터페이스 상속 implements 인터페이스명) > 구현체라는걸 만들어 세팅함 (.setBattery(battery:Battery) )

인터페이스의 두 가지 방법 > 1. 부품이 분리되는 형태에서 사용되는 인터페이스 ( 특징 : 인터페이스가 여러개의 메소드를 가짐, 마치 하나의 부품이 가지고 있어야할 모든 목록을 다 구현하고 있는것처럼 보여짐)
				    > 2. 코드의 일부분만 분리 즉 메소드의 일부분의 내용을 분리하는 인터페이스


<< 추상 클래스와 인터페이스의 차이 30강 >>

* 추상 클래스 : *객체들의 갖고있는 녀석의 일반화 또는 공통화를 클래스로 만듦 >> *공통으로써 있는것이 속성이라면 그걸 집중화 함 (멤버변수)
							   *기능적으로 같이 가지고 있어야할 공통분모의 기능, 서비스가 있으면 집중화하거나 강제화 할 수 있음 (추상 메소드)

	     * 추상클래스를 사용하는것이 누군지는 관심이 없고 중요한 것은 자식클래스들의 공통사항을 집중화하는것이 첫번쨰 목표
	     * 누군가가 추상화된 녀석을 가지다 사용하면 (Exam) Exam을 상속받는 객체들을 모두 사용할 수 있음.(NewlecExam, YBMExam의 공통분모인 Exam수준에서 사용하는 것이므로 공통분모를 가지고있는 하위 클래스도 사용가능)
		>> 따라서 Exam을 상속받고있는 녀석들에 대해서 일괄적으로 관리할 수 있게되는 클라이언트를 만들 수 있다.
	    ****** 따라서 추상클래스는 클라이언트(ExamConsole)와 상관없이 [Exam(NewlecExam YBMExam)==도구]이 먼저 존재하게됨 그리고 클라이언트가 어떤걸 사용할 것인지 결정지어짐 (선 도구 후 결정)

* 인터페이스 : 추상 클래스와 반대 클라이언트가 어떤 기능을 구현하고 서로다른(공통점이 없는) 객체임에도 기능을 사용할 수 있게 인터페이스를 만들고 인터페이스상속을 받으면 구현되어있는 클라이언트를 이용할 수 있다.
	    또한 여러개의 인터페이스를 상속받을 수 있음


>>>> 클래스 상속 : dna상속
>>>> 인터페이스 상속 : 사교적으로 필요에 따라 결합하는 상속
	    

